sem_init 用于创建一个信号量，并能初始化它的值。
sem_wait 和 sem_trywait 相当于 P 操作，它们都能将信号量的值减一，
两者的区别在于若信号量小于零时，sem_wait 将会阻塞进程，而 sem_trywait 则会立即返回。
sem_post 相当于 V 操作，它将信号量的值加一同时发出信号唤醒等待的进程。
sem_getvalue 获取信号量的值。
sem_destroy 删除信号量
有名信号量和无名信号量的区别和联系：
无名信号量的创建信号量函数是sem_init，有名信号量的则是sem_open函数。
无名信号量的删除信号量函数是sem_destroy，有名信号量的则是用sem_close函数关闭有名信号量，但是想要把信号量从文件系统删除得用sem_unlink函数。
其他的PV操作有名信号量是完全和无名信号量一致的。


条件变量

函数将解锁mutex参数指向的互斥锁，并使当前线程阻塞在cv参数指向的条件变量上。

被阻塞的线程可以被pthread_cond_signal函数，pthread_cond_broadcast函数唤醒，也可能在被信号中断后被唤醒。

pthread_cond_wait函数的返回并不意味着条件的值一定发生了变化，必须重新检查条件的值。

pthread_cond_wait函数返回时，相应的互斥锁将被当前线程锁定，即使是函数出错返回。

一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。
当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，
接着都试图再次占有相应的互斥锁。

阻塞在条件变量上的线程被唤醒以后，直到pthread_cond_wait()函数返回之前条件的值都有可能发生变化。
所以函数返回以后，在锁定相应的互斥锁之前，必须重新测试条件值。
最好的测试方法是循环调用pthread_cond_wait函数，并把满足条件的表达式置为循环的终止条件。





